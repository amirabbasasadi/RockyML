\hypertarget{flow_8h_source}{}\doxysection{flow.\+h}
\label{flow_8h_source}\index{include/rocky/zagros/flow.h@{include/rocky/zagros/flow.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/*}}
\DoxyCodeLine{2 \textcolor{comment}{    Copyright (C) 2022 Amirabbas Asadi , All Rights Reserved}}
\DoxyCodeLine{3 \textcolor{comment}{    distributed under Apache-\/2.0 license}}
\DoxyCodeLine{4 \textcolor{comment}{*/}}
\DoxyCodeLine{5 \textcolor{preprocessor}{\#ifndef ROCKY\_ZAGROS\_FLOW\_GUARD}}
\DoxyCodeLine{6 \textcolor{preprocessor}{\#define ROCKY\_ZAGROS\_FLOW\_GUARD}}
\DoxyCodeLine{7 }
\DoxyCodeLine{8 }
\DoxyCodeLine{9 \textcolor{preprocessor}{\#include<rocky/zagros/strategies/init.h>}}
\DoxyCodeLine{10 \textcolor{preprocessor}{\#include<rocky/zagros/strategies/log.h>}}
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include<rocky/zagros/strategies/pso.h>}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include<rocky/zagros/strategies/analysis.h>}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include<rocky/zagros/strategies/genetic.h>}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include<rocky/zagros/strategies/differential\_evolution.h>}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include<rocky/zagros/strategies/eda.h>}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include<rocky/zagros/strategies/blocked\_descent.h>}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include<rocky/zagros/dena.h>}}
\DoxyCodeLine{18 }
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 \textcolor{keyword}{namespace }rocky\{}
\DoxyCodeLine{22 \textcolor{keyword}{namespace }zagros\{}
\DoxyCodeLine{23 }
\DoxyCodeLine{28 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_e, \textcolor{keywordtype}{int} T\_dim, \textcolor{keywordtype}{int} T\_block\_dim>}
\DoxyCodeLine{29 \textcolor{keyword}{class }\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage}{runtime\_storage}}\{}
\DoxyCodeLine{30 \textcolor{keyword}{public}:}
\DoxyCodeLine{31     \textcolor{comment}{// allocated containers}}
\DoxyCodeLine{32     std::vector<std::unique\_ptr<basic\_scontainer<T\_e, T\_block\_dim>>> cnt\_storage;}
\DoxyCodeLine{33     \textcolor{comment}{// allocated strategies}}
\DoxyCodeLine{34     std::map<int, std::vector<std::unique\_ptr<basic\_strategy<T\_e, T\_block\_dim>>>> str\_storage;}
\DoxyCodeLine{35     \textcolor{comment}{// mapping the containers' id to their storage blocks}}
\DoxyCodeLine{36     std::map<std::string, int> cnt\_map;}
\DoxyCodeLine{37     \textcolor{comment}{// iteration counter for nodes who runs periodically}}
\DoxyCodeLine{38     std::map<int, int> iter\_counter;}
\DoxyCodeLine{39     \textcolor{comment}{// tracking the convergence of containers}}
\DoxyCodeLine{40     std::map<int, std::deque<T\_e>> conv\_tracker;}
\DoxyCodeLine{41     \textcolor{comment}{// a mask representing active variables in blocked descent}}
\DoxyCodeLine{42     std::vector<int> bcd\_mask;}
\DoxyCodeLine{43     \textcolor{comment}{// state of blocked systems}}
\DoxyCodeLine{44     std::unique\_ptr<basic\_scontainer<T\_e, T\_dim>> blocked\_state;}
\DoxyCodeLine{45     tbb::enumerable\_thread\_specific<std::vector<T\_e>> th\_blocked\_states;}
\DoxyCodeLine{46     \textcolor{comment}{// a temp buffer for broadcasting best partial solution}}
\DoxyCodeLine{47     std::unique\_ptr<basic\_scontainer<T\_e, T\_block\_dim>> partial\_best;}
\DoxyCodeLine{48     \textcolor{comment}{// amount of allocated memory}}
\DoxyCodeLine{49     \textcolor{keywordtype}{size\_t} container\_space()\{}
\DoxyCodeLine{50         \textcolor{keywordtype}{size\_t} allocated\_mem = 0;}
\DoxyCodeLine{51         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} \textcolor{keyword}{const}\& cnt: cnt\_storage)}
\DoxyCodeLine{52             allocated\_mem += cnt-\/>space();}
\DoxyCodeLine{53         \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr}(T\_dim != T\_block\_dim)\{}
\DoxyCodeLine{54             allocated\_mem += blocked\_state-\/>space();}
\DoxyCodeLine{55             allocated\_mem += partial\_best-\/>space();}
\DoxyCodeLine{56             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} \textcolor{keyword}{const}\& th\_state: th\_blocked\_states)}
\DoxyCodeLine{57                 allocated\_mem += th\_state.size() * \textcolor{keyword}{sizeof}(T\_e);}
\DoxyCodeLine{58         \}}
\DoxyCodeLine{59         \textcolor{keywordflow}{return} allocated\_mem;}
\DoxyCodeLine{60     \}}
\DoxyCodeLine{66     \textcolor{keywordtype}{bool} \mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_aca16d7772ce582c7d637d34275c20078}{container\_exist}}(std::string \textcolor{keywordtype}{id})\{}
\DoxyCodeLine{67         \textcolor{keyword}{auto} it = cnt\_map.find(\textcolor{keywordtype}{id});}
\DoxyCodeLine{68         \textcolor{keywordflow}{return} it != cnt\_map.end();}
\DoxyCodeLine{69     \}}
\DoxyCodeLine{76     \mbox{\hyperlink{classrocky_1_1zagros_1_1basic__scontainer}{basic\_scontainer<T\_e, T\_block\_dim>}}* \mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(std::string \textcolor{keywordtype}{id})\{}
\DoxyCodeLine{77         \textcolor{keywordflow}{if} (\textcolor{keywordtype}{id} == std::string(\textcolor{stringliteral}{"{}\_\_best\_\_"{}}))}
\DoxyCodeLine{78             \textcolor{keywordflow}{return} partial\_best.get();}
\DoxyCodeLine{79 }
\DoxyCodeLine{80         \textcolor{keywordflow}{if} (!\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_aca16d7772ce582c7d637d34275c20078}{container\_exist}}(\textcolor{keywordtype}{id}))\{}
\DoxyCodeLine{81             spdlog::warn(\textcolor{stringliteral}{"{}container \{\} does not exist"{}}, \textcolor{keywordtype}{id});}
\DoxyCodeLine{82         \}}
\DoxyCodeLine{83         \textcolor{comment}{// find the target container}}
\DoxyCodeLine{84         \textcolor{keywordtype}{int} target\_cnt\_ind = cnt\_map[id];}
\DoxyCodeLine{85         \textcolor{keywordflow}{return} cnt\_storage[target\_cnt\_ind].get();}
\DoxyCodeLine{86     \}}
\DoxyCodeLine{87     \textcolor{keywordtype}{void} allocate\_container(std::string \textcolor{keywordtype}{id}, \textcolor{keywordtype}{int} n\_particles, \textcolor{keywordtype}{int} group\_size)\{}
\DoxyCodeLine{88          \textcolor{comment}{// allocate a continer}}
\DoxyCodeLine{89         \textcolor{keyword}{auto} cnt = std::make\_unique<basic\_scontainer<T\_e, T\_block\_dim>>(n\_particles, group\_size);}
\DoxyCodeLine{90         cnt-\/>allocate();}
\DoxyCodeLine{91         spdlog::info(\textcolor{stringliteral}{"{}container \{\} was allocated. size : \{:.2f\} MB"{}}, \textcolor{keywordtype}{id}, cnt-\/>space()/(1024.0*1024.0));}
\DoxyCodeLine{92         cnt\_storage.push\_back(std::move(cnt));}
\DoxyCodeLine{93         \textcolor{comment}{// register the id in the storage}}
\DoxyCodeLine{94         cnt\_map[id] = cnt\_storage.size()-\/1;}
\DoxyCodeLine{95     \}}
\DoxyCodeLine{96     \textcolor{comment}{// find the best partial solution in the storage}}
\DoxyCodeLine{97     \textcolor{keywordtype}{void} update\_partial\_best()\{}
\DoxyCodeLine{98         std::pair<T\_e, int> best;}
\DoxyCodeLine{99         \textcolor{keywordtype}{int} best\_ci = -\/1;}
\DoxyCodeLine{100         best.first = std::numeric\_limits<T\_e>::max();}
\DoxyCodeLine{101         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} ci=0; ci<cnt\_storage.size(); ci++)\{}
\DoxyCodeLine{102             \textcolor{keyword}{auto} min\_and\_index = cnt\_storage[ci]-\/>best\_min\_index();}
\DoxyCodeLine{103             \textcolor{keywordflow}{if}((min\_and\_index.first < best.first) || best\_ci == -\/1)\{}
\DoxyCodeLine{104                 best = min\_and\_index;}
\DoxyCodeLine{105                 best\_ci = ci;}
\DoxyCodeLine{106             \}        }
\DoxyCodeLine{107         \}}
\DoxyCodeLine{108         \textcolor{keywordflow}{if} (best.first < partial\_best-\/>values[0])\{}
\DoxyCodeLine{109             \textcolor{comment}{// copy the best solution to the container}}
\DoxyCodeLine{110             std::copy(cnt\_storage[best\_ci]-\/>particle(best.second),}
\DoxyCodeLine{111                     cnt\_storage[best\_ci]-\/>particle(best.second)+T\_block\_dim,}
\DoxyCodeLine{112                     partial\_best-\/>particle(0));}
\DoxyCodeLine{113             }
\DoxyCodeLine{114             \textcolor{comment}{// copy the corresponding min value}}
\DoxyCodeLine{115             partial\_best-\/>values[0] = best.first;}
\DoxyCodeLine{116         \}}
\DoxyCodeLine{117     \}}
\DoxyCodeLine{118     \textcolor{comment}{// synchronize best partial solution}}
\DoxyCodeLine{119     \textcolor{keywordtype}{void} sync\_partial\_best()\{}
\DoxyCodeLine{120         \textcolor{comment}{// Assumption : update\_partial\_best has been called already}}
\DoxyCodeLine{121         \textcolor{comment}{// This function must be called before regenerating BCD mask}}
\DoxyCodeLine{122         sync\_broadcast\_best<T\_e, T\_block\_dim> sync\_best\_partial\_str(partial\_best.get());}
\DoxyCodeLine{123         sync\_best\_partial\_str.apply();}
\DoxyCodeLine{124         \textcolor{comment}{// replace the old partial solution in solution states}}
\DoxyCodeLine{125         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<T\_block\_dim; i++)}
\DoxyCodeLine{126             blocked\_state-\/>particles[0][bcd\_mask[i]] = partial\_best-\/>particles[0][i];}
\DoxyCodeLine{127         \textcolor{comment}{// replace the old partial solution in thread-\/specific states}}
\DoxyCodeLine{128         \textcolor{keywordtype}{int} i=0;}
\DoxyCodeLine{129         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\& th\_state: th\_blocked\_states)\{}
\DoxyCodeLine{130             th\_state[bcd\_mask[i]] = partial\_best-\/>particles[0][i];}
\DoxyCodeLine{131             i++;}
\DoxyCodeLine{132         \}}
\DoxyCodeLine{133     \}}
\DoxyCodeLine{134     \textcolor{comment}{// reset all solution containers}}
\DoxyCodeLine{135     \textcolor{keywordtype}{void} reset()\{}
\DoxyCodeLine{136         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\& cnt: cnt\_storage)}
\DoxyCodeLine{137             cnt-\/>reset\_values();}
\DoxyCodeLine{138         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\& [tag, str\_vec]: str\_storage)}
\DoxyCodeLine{139             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\& str: str\_vec)}
\DoxyCodeLine{140                 str-\/>reset();}
\DoxyCodeLine{141     \}}
\DoxyCodeLine{142 \};}
\DoxyCodeLine{143 }
\DoxyCodeLine{144 }
\DoxyCodeLine{145 }
\DoxyCodeLine{150 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_e, \textcolor{keywordtype}{int} T\_dim, \textcolor{keywordtype}{int} T\_block\_dim>}
\DoxyCodeLine{151 \textcolor{keyword}{struct }\mbox{\hyperlink{structrocky_1_1zagros_1_1allocation__visitor}{allocation\_visitor}}\{}
\DoxyCodeLine{152     \textcolor{comment}{// objective system}}
\DoxyCodeLine{153     \mbox{\hyperlink{classrocky_1_1zagros_1_1system}{system<T\_e>}}* problem;}
\DoxyCodeLine{154     \textcolor{comment}{// visitor will change main storage}}
\DoxyCodeLine{155     \mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage}{runtime\_storage<T\_e, T\_dim, T\_block\_dim>}}* main\_storage;}
\DoxyCodeLine{156     \textcolor{comment}{// visitor may also change the path stack in the case of composable flows}}
\DoxyCodeLine{157     std::stack<int>* path\_stack;}
\DoxyCodeLine{158 }
\DoxyCodeLine{159     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1bcd__mask__node}{dena::bcd\_mask\_node}} node)\{\}}
\DoxyCodeLine{160     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1log__local__best__node}{dena::log\_local\_best\_node}} node)\{\}}
\DoxyCodeLine{161     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1log__comet__best__node}{dena::log\_comet\_best\_node}} node)\{\}}
\DoxyCodeLine{162     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1comm__cluster__prop__best}{dena::comm\_cluster\_prop\_best}} node)\{\}}
\DoxyCodeLine{163     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1init__uniform}{dena::init\_uniform}} node)\{\}}
\DoxyCodeLine{164     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1init__normal}{dena::init\_normal}} node)\{\}}
\DoxyCodeLine{165     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1run__n__times__node}{dena::run\_n\_times\_node}} node)\{}
\DoxyCodeLine{166         path\_stack-\/>push(node.sub\_procedure.front());}
\DoxyCodeLine{167     \}}
\DoxyCodeLine{168     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1run__until__no__improve__node}{dena::run\_until\_no\_improve\_node}} node)\{}
\DoxyCodeLine{169         main\_storage-\/>conv\_tracker[node.tag] = std::deque<T\_e>();}
\DoxyCodeLine{170         path\_stack-\/>push(node.sub\_procedure.front());}
\DoxyCodeLine{171     \}}
\DoxyCodeLine{172     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1run__every__n__steps__node}{dena::run\_every\_n\_steps\_node}} node)\{}
\DoxyCodeLine{173         main\_storage-\/>iter\_counter[node.tag] = 0;}
\DoxyCodeLine{174         path\_stack-\/>push(node.sub\_procedure.front());}
\DoxyCodeLine{175     \}}
\DoxyCodeLine{176     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1run__with__probability__node}{dena::run\_with\_probability\_node}} node)\{}
\DoxyCodeLine{177         path\_stack-\/>push(node.sub\_procedure.front());}
\DoxyCodeLine{178     \}}
\DoxyCodeLine{179     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1container__create__node}{dena::container\_create\_node}} node)\{}
\DoxyCodeLine{180         main\_storage-\/>allocate\_container(node.id, node.n\_particles, node.group\_size);}
\DoxyCodeLine{181     \}}
\DoxyCodeLine{182     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1pso__memory__create__node}{dena::pso\_memory\_create\_node}} node)\{}
\DoxyCodeLine{183         \textcolor{comment}{// allocate required solution containers for particle swarm}}
\DoxyCodeLine{184         \textcolor{keyword}{auto} main\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(node.main\_cnt\_id);}
\DoxyCodeLine{185         \textcolor{keywordtype}{int} n\_particles = main\_cnt-\/>n\_particles();}
\DoxyCodeLine{186         \textcolor{keywordtype}{int} n\_groups = main\_cnt-\/>n\_groups();}
\DoxyCodeLine{187         \textcolor{keywordtype}{int} group\_size = main\_cnt-\/>group\_size();}
\DoxyCodeLine{188 }
\DoxyCodeLine{189         \textcolor{keyword}{using namespace }dena;}
\DoxyCodeLine{190         \textcolor{comment}{// particles velocity}}
\DoxyCodeLine{191         main\_storage-\/>allocate\_container(pso::memory::particles\_vel(node.memory\_id), n\_particles, group\_size);}
\DoxyCodeLine{192         \textcolor{comment}{// particles memory}}
\DoxyCodeLine{193         main\_storage-\/>allocate\_container(pso::memory::particles\_mem(node.memory\_id), n\_particles, group\_size);}
\DoxyCodeLine{194         \textcolor{comment}{// groups memory}}
\DoxyCodeLine{195         main\_storage-\/>allocate\_container(pso::memory::groups\_mem(node.memory\_id), n\_groups, 1);}
\DoxyCodeLine{196         \textcolor{comment}{// node memory}}
\DoxyCodeLine{197         main\_storage-\/>allocate\_container(pso::memory::node\_mem(node.memory\_id), 1, 1);}
\DoxyCodeLine{198         \textcolor{comment}{// cluster memory}}
\DoxyCodeLine{199         main\_storage-\/>allocate\_container(pso::memory::cluster\_mem(node.memory\_id), 1, 1);}
\DoxyCodeLine{200     \}}
\DoxyCodeLine{201     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1pso__group__level__step__node}{dena::pso\_group\_level\_step\_node}} node)\{\}}
\DoxyCodeLine{202     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1pso__cluster__level__step__node}{dena::pso\_cluster\_level\_step\_node}} node)\{\}}
\DoxyCodeLine{203     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1mutate__gaussian__node}{dena::mutate\_gaussian\_node}} node)\{}
\DoxyCodeLine{204         \textcolor{comment}{// allocate required solution containers for particle swarm}}
\DoxyCodeLine{205         \textcolor{keyword}{auto} main\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(node.id);}
\DoxyCodeLine{206         \textcolor{keywordtype}{int} n\_particles = main\_cnt-\/>n\_particles();}
\DoxyCodeLine{207         main\_storage-\/>allocate\_container(\mbox{\hyperlink{classrocky_1_1zagros_1_1dena_1_1utils_a585cb0fb9000379dcde2587611d12604}{dena::utils::temp\_name}}(node.tag), n\_particles, n\_particles);}
\DoxyCodeLine{208     \}}
\DoxyCodeLine{209     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1crossover__multipoint__node}{dena::crossover\_multipoint\_node}} node)\{}
\DoxyCodeLine{210         \textcolor{comment}{// allocate required solution container}}
\DoxyCodeLine{211         \textcolor{keyword}{auto} main\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(node.id);}
\DoxyCodeLine{212         \textcolor{keywordtype}{int} n\_particles = main\_cnt-\/>n\_particles();}
\DoxyCodeLine{213         main\_storage-\/>allocate\_container(\mbox{\hyperlink{classrocky_1_1zagros_1_1dena_1_1utils_a585cb0fb9000379dcde2587611d12604}{dena::utils::temp\_name}}(node.tag), n\_particles, n\_particles);}
\DoxyCodeLine{214     \}}
\DoxyCodeLine{215     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1crossover__differential__evolution__node}{dena::crossover\_differential\_evolution\_node}} node)\{}
\DoxyCodeLine{216         \textcolor{comment}{// allocate required solution container}}
\DoxyCodeLine{217         \textcolor{keyword}{auto} main\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(node.id);}
\DoxyCodeLine{218         \textcolor{keywordtype}{int} n\_particles = main\_cnt-\/>n\_particles();}
\DoxyCodeLine{219         main\_storage-\/>allocate\_container(\mbox{\hyperlink{classrocky_1_1zagros_1_1dena_1_1utils_a585cb0fb9000379dcde2587611d12604}{dena::utils::temp\_name}}(node.tag), n\_particles, n\_particles);}
\DoxyCodeLine{220     \}}
\DoxyCodeLine{221     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1eda__mvn__fullcov__node}{dena::eda\_mvn\_fullcov\_node}} node)\{}
\DoxyCodeLine{222         \textcolor{comment}{// allocate required solution container}}
\DoxyCodeLine{223         \textcolor{keyword}{auto} main\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(node.id);}
\DoxyCodeLine{224         \textcolor{keywordtype}{int} n\_particles = main\_cnt-\/>n\_particles();}
\DoxyCodeLine{225         \textcolor{keywordtype}{int} temp\_size = T\_dim;}
\DoxyCodeLine{226         \textcolor{keywordflow}{if}(n\_particles < temp\_size)\{}
\DoxyCodeLine{227             temp\_size = n\_particles;}
\DoxyCodeLine{228             spdlog::warn(\textcolor{stringliteral}{"{}For using EDA it is recommended to choose number of particles larger than BCD block"{}});}
\DoxyCodeLine{229         \}}
\DoxyCodeLine{230         main\_storage-\/>allocate\_container(\mbox{\hyperlink{classrocky_1_1zagros_1_1dena_1_1utils_a585cb0fb9000379dcde2587611d12604}{dena::utils::temp\_name}}(node.tag), T\_block\_dim, T\_block\_dim);}
\DoxyCodeLine{231     \}}
\DoxyCodeLine{232     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1crossover__segment__node}{dena::crossover\_segment\_node}} node)\{}
\DoxyCodeLine{233         \textcolor{comment}{// allocate required solution container}}
\DoxyCodeLine{234         \textcolor{keyword}{auto} main\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(node.id);}
\DoxyCodeLine{235         \textcolor{keywordtype}{int} n\_particles = main\_cnt-\/>n\_particles();}
\DoxyCodeLine{236         main\_storage-\/>allocate\_container(\mbox{\hyperlink{classrocky_1_1zagros_1_1dena_1_1utils_a585cb0fb9000379dcde2587611d12604}{dena::utils::temp\_name}}(node.tag), n\_particles, n\_particles);}
\DoxyCodeLine{237     \}}
\DoxyCodeLine{238     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1plot__heatmap__node}{dena::plot\_heatmap\_node}} node)\{\}}
\DoxyCodeLine{239 \};}
\DoxyCodeLine{244 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_e, \textcolor{keywordtype}{int} T\_dim, \textcolor{keywordtype}{int} T\_block\_dim>}
\DoxyCodeLine{245 \textcolor{keyword}{struct }\mbox{\hyperlink{structrocky_1_1zagros_1_1assigning__visitor}{assigning\_visitor}}\{}
\DoxyCodeLine{246     \textcolor{comment}{// objective system}}
\DoxyCodeLine{247     \mbox{\hyperlink{classrocky_1_1zagros_1_1system}{system<T\_e>}}* problem;}
\DoxyCodeLine{248     \textcolor{comment}{// visitor will change main storage}}
\DoxyCodeLine{249     \mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage}{runtime\_storage<T\_e, T\_dim, T\_block\_dim>}}* main\_storage;}
\DoxyCodeLine{250     \textcolor{comment}{// visitor may also change the path stack in the case of composable flows}}
\DoxyCodeLine{251     std::stack<int>* path\_stack;}
\DoxyCodeLine{252     }
\DoxyCodeLine{253     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1bcd__mask__node}{dena::bcd\_mask\_node}} node)\{}
\DoxyCodeLine{254         \textcolor{comment}{// reserve the mask generation strategy}}
\DoxyCodeLine{255         \textcolor{keyword}{auto} gen\_str = std::make\_unique<bcd\_mask\_uniform\_random<T\_e, T\_block\_dim>>(\textcolor{keyword}{dynamic\_cast<}\mbox{\hyperlink{classrocky_1_1zagros_1_1blocked__system}{blocked\_system<T\_e>}}*\textcolor{keyword}{>}(problem), \&(main\_storage-\/>bcd\_mask));}
\DoxyCodeLine{256         \textcolor{comment}{// add the strategy to the container}}
\DoxyCodeLine{257         main\_storage-\/>str\_storage[node.tag].push\_back(std::move(gen\_str));}
\DoxyCodeLine{258         \textcolor{comment}{// reserve the mask synchronization strategy}}
\DoxyCodeLine{259         \textcolor{keyword}{auto} sync\_str = std::make\_unique<sync\_bcd\_mask<T\_e, T\_block\_dim>>(main\_storage-\/>bcd\_mask.data());}
\DoxyCodeLine{260         \textcolor{comment}{// add the strategy to the container}}
\DoxyCodeLine{261         main\_storage-\/>str\_storage[node.tag].push\_back(std::move(sync\_str));}
\DoxyCodeLine{262     \}}
\DoxyCodeLine{263     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1log__local__best__node}{dena::log\_local\_best\_node}} node)\{}
\DoxyCodeLine{264         \mbox{\hyperlink{classrocky_1_1zagros_1_1basic__scontainer}{basic\_scontainer<T\_e, T\_block\_dim>}}* target\_cnt = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{265         \textcolor{keywordflow}{if}(node.id.size() == 0)}
\DoxyCodeLine{266             target\_cnt = main\_storage-\/>partial\_best.get();}
\DoxyCodeLine{267         \textcolor{keywordflow}{else}}
\DoxyCodeLine{268             target\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(node.id);}
\DoxyCodeLine{269         \textcolor{comment}{// reserve the strategy}}
\DoxyCodeLine{270         \textcolor{keyword}{auto} str = std::make\_unique<local\_log\_best<T\_e, T\_block\_dim>>(problem, target\_cnt, node.handler);}
\DoxyCodeLine{271         \textcolor{comment}{// add the strategy to the container}}
\DoxyCodeLine{272         main\_storage-\/>str\_storage[node.tag].push\_back(std::move(str));}
\DoxyCodeLine{273     \}}
\DoxyCodeLine{274     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1log__comet__best__node}{dena::log\_comet\_best\_node}} node)\{}
\DoxyCodeLine{275         \mbox{\hyperlink{classrocky_1_1zagros_1_1basic__scontainer}{basic\_scontainer<T\_e, T\_block\_dim>}}* target\_cnt = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{276         \textcolor{keywordflow}{if}(node.id.size() == 0)}
\DoxyCodeLine{277             target\_cnt = main\_storage-\/>partial\_best.get();}
\DoxyCodeLine{278         \textcolor{keywordflow}{else}}
\DoxyCodeLine{279             target\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(node.id);}
\DoxyCodeLine{280         \textcolor{comment}{// reserve the strategy}}
\DoxyCodeLine{281         \textcolor{keyword}{auto} str = std::make\_unique<comet\_log\_best<T\_e, T\_block\_dim>>(problem, target\_cnt, node.handler);}
\DoxyCodeLine{282         \textcolor{comment}{// add the strategy to the container}}
\DoxyCodeLine{283         main\_storage-\/>str\_storage[node.tag].push\_back(std::move(str));}
\DoxyCodeLine{284     \}}
\DoxyCodeLine{285     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1comm__cluster__prop__best}{dena::comm\_cluster\_prop\_best}} node)\{}
\DoxyCodeLine{286         \textcolor{comment}{// retrieve the target container}}
\DoxyCodeLine{287         \textcolor{keyword}{auto} target\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(node.id);}
\DoxyCodeLine{288         \textcolor{comment}{// create and configure the strategy}}
\DoxyCodeLine{289         \textcolor{keyword}{auto} str = std::make\_unique<sync\_broadcast\_best<T\_e, T\_block\_dim>>(target\_cnt);}
\DoxyCodeLine{290         \textcolor{comment}{// register the strategy}}
\DoxyCodeLine{291         main\_storage-\/>str\_storage[node.tag].push\_back(std::move(str));}
\DoxyCodeLine{292     \}}
\DoxyCodeLine{293     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1init__uniform}{dena::init\_uniform}} node)\{}
\DoxyCodeLine{294         \textcolor{comment}{// get the target container}}
\DoxyCodeLine{295         \textcolor{keyword}{auto} target\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(node.id);}
\DoxyCodeLine{296         \textcolor{comment}{// reserve the strategy}}
\DoxyCodeLine{297         \textcolor{keyword}{auto} str = std::make\_unique<uniform\_init\_strategy<T\_e, T\_block\_dim>>(problem, target\_cnt);}
\DoxyCodeLine{298         \textcolor{comment}{// add the strategy to the container}}
\DoxyCodeLine{299         main\_storage-\/>str\_storage[node.tag].push\_back(std::move(str));}
\DoxyCodeLine{300     \}}
\DoxyCodeLine{301     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1init__normal}{dena::init\_normal}} node)\{\}}
\DoxyCodeLine{302     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1run__n__times__node}{dena::run\_n\_times\_node}} node)\{}
\DoxyCodeLine{303         path\_stack-\/>push(node.sub\_procedure.front());}
\DoxyCodeLine{304     \}}
\DoxyCodeLine{305     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1run__with__probability__node}{dena::run\_with\_probability\_node}} node)\{}
\DoxyCodeLine{306         path\_stack-\/>push(node.sub\_procedure.front());}
\DoxyCodeLine{307     \}}
\DoxyCodeLine{308     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1run__until__no__improve__node}{dena::run\_until\_no\_improve\_node}} node)\{}
\DoxyCodeLine{309         path\_stack-\/>push(node.sub\_procedure.front());}
\DoxyCodeLine{310     \}}
\DoxyCodeLine{311     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1run__every__n__steps__node}{dena::run\_every\_n\_steps\_node}} node)\{}
\DoxyCodeLine{312         path\_stack-\/>push(node.sub\_procedure.front());}
\DoxyCodeLine{313     \}}
\DoxyCodeLine{314     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1container__create__node}{dena::container\_create\_node}} node)\{\}}
\DoxyCodeLine{315     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1pso__memory__create__node}{dena::pso\_memory\_create\_node}} node)\{\}}
\DoxyCodeLine{316     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1pso__group__level__step__node}{dena::pso\_group\_level\_step\_node}} node)\{}
\DoxyCodeLine{317         \textcolor{comment}{// get memory containers}}
\DoxyCodeLine{318         \textcolor{keyword}{using namespace }dena;}
\DoxyCodeLine{319         \textcolor{keyword}{auto} main\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(node.main\_cnt\_id);}
\DoxyCodeLine{320         \textcolor{keyword}{auto} particles\_v = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(pso::memory::particles\_vel(node.memory\_id));}
\DoxyCodeLine{321         \textcolor{keyword}{auto} particles\_mem = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(pso::memory::particles\_mem(node.memory\_id));}
\DoxyCodeLine{322         \textcolor{keyword}{auto} groups\_mem = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(pso::memory::groups\_mem(node.memory\_id));}
\DoxyCodeLine{323         \textcolor{keyword}{auto} node\_mem = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(pso::memory::node\_mem(node.memory\_id));}
\DoxyCodeLine{324         \textcolor{keyword}{auto} cluster\_mem = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(pso::memory::cluster\_mem(node.memory\_id));}
\DoxyCodeLine{325         \textcolor{keyword}{auto} str = std::make\_unique<pso\_l1\_strategy<T\_e, T\_block\_dim>>(problem, main\_cnt, particles\_v, particles\_mem, groups\_mem, node\_mem, cluster\_mem);}
\DoxyCodeLine{326         \textcolor{comment}{// add the strategy to the container}}
\DoxyCodeLine{327         main\_storage-\/>str\_storage[node.tag].push\_back(std::move(str));}
\DoxyCodeLine{328     \}}
\DoxyCodeLine{329     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1pso__cluster__level__step__node}{dena::pso\_cluster\_level\_step\_node}} node)\{}
\DoxyCodeLine{330         \textcolor{comment}{// get memory containers}}
\DoxyCodeLine{331         \textcolor{keyword}{using namespace }dena;}
\DoxyCodeLine{332         \textcolor{keyword}{auto} main\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(node.main\_cnt\_id);}
\DoxyCodeLine{333         \textcolor{keyword}{auto} particles\_v = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(pso::memory::particles\_vel(node.memory\_id));}
\DoxyCodeLine{334         \textcolor{keyword}{auto} particles\_mem = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(pso::memory::particles\_mem(node.memory\_id));}
\DoxyCodeLine{335         \textcolor{keyword}{auto} groups\_mem = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(pso::memory::groups\_mem(node.memory\_id));}
\DoxyCodeLine{336         \textcolor{keyword}{auto} node\_mem = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(pso::memory::node\_mem(node.memory\_id));}
\DoxyCodeLine{337         \textcolor{keyword}{auto} cluster\_mem = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(pso::memory::cluster\_mem(node.memory\_id));}
\DoxyCodeLine{338         \textcolor{keyword}{auto} str = std::make\_unique<pso\_l3\_strategy<T\_e, T\_block\_dim>>(problem, main\_cnt, particles\_v, particles\_mem, groups\_mem, node\_mem, cluster\_mem);}
\DoxyCodeLine{339         \textcolor{comment}{// add the strategy to the container}}
\DoxyCodeLine{340         main\_storage-\/>str\_storage[node.tag].push\_back(std::move(str));}
\DoxyCodeLine{341     \}}
\DoxyCodeLine{342     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1mutate__gaussian__node}{dena::mutate\_gaussian\_node}} node)\{}
\DoxyCodeLine{343         \textcolor{keyword}{auto} main\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(node.id);}
\DoxyCodeLine{344         \textcolor{keyword}{auto} temp\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(\mbox{\hyperlink{classrocky_1_1zagros_1_1dena_1_1utils_a585cb0fb9000379dcde2587611d12604}{dena::utils::temp\_name}}(node.tag));}
\DoxyCodeLine{345         \textcolor{keyword}{auto} str = std::make\_unique<gaussian\_mutation<T\_e, T\_block\_dim>>(problem, main\_cnt, temp\_cnt, node.dims, node.mu, node.sigma);}
\DoxyCodeLine{346         \textcolor{comment}{// add the strategy to the container}}
\DoxyCodeLine{347         main\_storage-\/>str\_storage[node.tag].push\_back(std::move(str));}
\DoxyCodeLine{348     \}}
\DoxyCodeLine{349     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1crossover__multipoint__node}{dena::crossover\_multipoint\_node}} node)\{}
\DoxyCodeLine{350         \textcolor{keyword}{auto} main\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(node.id);}
\DoxyCodeLine{351         \textcolor{keyword}{auto} temp\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(\mbox{\hyperlink{classrocky_1_1zagros_1_1dena_1_1utils_a585cb0fb9000379dcde2587611d12604}{dena::utils::temp\_name}}(node.tag));}
\DoxyCodeLine{352         \textcolor{keyword}{auto} str = std::make\_unique<multipoint\_crossover<T\_e, T\_block\_dim>>(problem, main\_cnt, temp\_cnt, node.dims);}
\DoxyCodeLine{353         \textcolor{comment}{// add the strategy to the container}}
\DoxyCodeLine{354         main\_storage-\/>str\_storage[node.tag].push\_back(std::move(str));}
\DoxyCodeLine{355     \}}
\DoxyCodeLine{356     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1crossover__differential__evolution__node}{dena::crossover\_differential\_evolution\_node}} node)\{}
\DoxyCodeLine{357         \textcolor{keyword}{auto} main\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(node.id);}
\DoxyCodeLine{358         \textcolor{keyword}{auto} temp\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(\mbox{\hyperlink{classrocky_1_1zagros_1_1dena_1_1utils_a585cb0fb9000379dcde2587611d12604}{dena::utils::temp\_name}}(node.tag));}
\DoxyCodeLine{359         \textcolor{keyword}{auto} str = std::make\_unique<basic\_differential\_evolution<T\_e, T\_block\_dim>>(problem, main\_cnt, temp\_cnt, node.crossover\_prob, node.differential\_weight);}
\DoxyCodeLine{360         \textcolor{comment}{// add the strategy to the container}}
\DoxyCodeLine{361         main\_storage-\/>str\_storage[node.tag].push\_back(std::move(str));}
\DoxyCodeLine{362     \}}
\DoxyCodeLine{363     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1eda__mvn__fullcov__node}{dena::eda\_mvn\_fullcov\_node}} node)\{}
\DoxyCodeLine{364         \textcolor{keyword}{auto} main\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(node.id);}
\DoxyCodeLine{365         \textcolor{keyword}{auto} temp\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(\mbox{\hyperlink{classrocky_1_1zagros_1_1dena_1_1utils_a585cb0fb9000379dcde2587611d12604}{dena::utils::temp\_name}}(node.tag));}
\DoxyCodeLine{366         \textcolor{keyword}{auto} str = std::make\_unique<eda\_mutivariate\_normal<T\_e, T\_block\_dim>>(problem, main\_cnt, temp\_cnt, T\_block\_dim);}
\DoxyCodeLine{367         \textcolor{comment}{// add the strategy to the container}}
\DoxyCodeLine{368         main\_storage-\/>str\_storage[node.tag].push\_back(std::move(str));}
\DoxyCodeLine{369     \}}
\DoxyCodeLine{370     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1crossover__segment__node}{dena::crossover\_segment\_node}} node)\{}
\DoxyCodeLine{371         \textcolor{keyword}{auto} main\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(node.id);}
\DoxyCodeLine{372         \textcolor{keyword}{auto} temp\_cnt = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(\mbox{\hyperlink{classrocky_1_1zagros_1_1dena_1_1utils_a585cb0fb9000379dcde2587611d12604}{dena::utils::temp\_name}}(node.tag));}
\DoxyCodeLine{373         \textcolor{keywordtype}{int} segment\_length = node.segment\_length;}
\DoxyCodeLine{374         \textcolor{keywordflow}{if} (segment\_length >= T\_block\_dim)\{}
\DoxyCodeLine{375             \textcolor{keywordtype}{int} segment\_length = std::max(T\_block\_dim-\/1, 1);}
\DoxyCodeLine{376             spdlog::warn(\textcolor{stringliteral}{"{}segment length must be less than BCD block size!"{}});}
\DoxyCodeLine{377         \}}
\DoxyCodeLine{378         \textcolor{keyword}{auto} str = std::make\_unique<static\_segment\_crossover<T\_e, T\_block\_dim>>(problem, main\_cnt, temp\_cnt, segment\_length);}
\DoxyCodeLine{379         \textcolor{comment}{// add the strategy to the container}}
\DoxyCodeLine{380         main\_storage-\/>str\_storage[node.tag].push\_back(std::move(str));}
\DoxyCodeLine{381     \}}
\DoxyCodeLine{382     \textcolor{keywordtype}{void} operator()(\mbox{\hyperlink{structrocky_1_1zagros_1_1dena_1_1plot__heatmap__node}{dena::plot\_heatmap\_node}} node)\{}
\DoxyCodeLine{383         \textcolor{keywordflow}{if} (T\_block\_dim != 2)\{}
\DoxyCodeLine{384             spdlog::warn(\textcolor{stringliteral}{"{}For using heatmap the block dimension should be 2."{}});}
\DoxyCodeLine{385         \}}
\DoxyCodeLine{386         T\_e x\_min = problem-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1system_a8c585163cd377259b6bff2fd9f91276f}{lower\_bound}}(0);}
\DoxyCodeLine{387         T\_e y\_min = problem-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1system_a8c585163cd377259b6bff2fd9f91276f}{lower\_bound}}(1);}
\DoxyCodeLine{388         T\_e x\_max = problem-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1system_a93ad8b3e28cafbcaecfc14e92c8224dc}{upper\_bound}}(0);}
\DoxyCodeLine{389         T\_e y\_max = problem-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1system_a93ad8b3e28cafbcaecfc14e92c8224dc}{upper\_bound}}(1);}
\DoxyCodeLine{390 }
\DoxyCodeLine{391         \textcolor{keyword}{auto} str = std::make\_unique<loss\_projection\_2d<T\_e, T\_block\_dim>>(problem, node.label, node.width, node.height, x\_min, y\_min, x\_max, y\_max);}
\DoxyCodeLine{392         main\_storage-\/>str\_storage[node.tag].push\_back(std::move(str));}
\DoxyCodeLine{393     \}}
\DoxyCodeLine{394 \};}
\DoxyCodeLine{395 }
\DoxyCodeLine{400 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_e, \textcolor{keywordtype}{int} T\_dim, \textcolor{keywordtype}{int} T\_block\_dim, \textcolor{keyword}{typename} T\_traverse\_fn>}
\DoxyCodeLine{401 \textcolor{keyword}{struct }\mbox{\hyperlink{structrocky_1_1zagros_1_1running__visitor}{running\_visitor}}\{}
\DoxyCodeLine{402     \textcolor{comment}{// objective system}}
\DoxyCodeLine{403     \mbox{\hyperlink{classrocky_1_1zagros_1_1system}{system<T\_e>}}* problem;}
\DoxyCodeLine{404     \textcolor{comment}{// visitor will change main storage}}
\DoxyCodeLine{405     \mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage}{runtime\_storage<T\_e, T\_dim, T\_block\_dim>}}* main\_storage;}
\DoxyCodeLine{406     \textcolor{comment}{// visitor may also change the path stack in the case of composable flows}}
\DoxyCodeLine{407     T\_traverse\_fn* traverse\_fn;}
\DoxyCodeLine{408 }
\DoxyCodeLine{409     \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_n>}
\DoxyCodeLine{410     \textcolor{keywordtype}{void} operator()(T\_n node)\{}
\DoxyCodeLine{411         \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_base\_of<dena::run\_node, T\_n>::value)\{}
\DoxyCodeLine{412             \textcolor{comment}{// run n times}}
\DoxyCodeLine{413             \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_base\_of<dena::run\_n\_times\_node, T\_n>::value)\{}
\DoxyCodeLine{414                 \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<node.n\_iters; i++)\{}
\DoxyCodeLine{415                     (*traverse\_fn)(node.sub\_procedure.front(), problem, main\_storage);}
\DoxyCodeLine{416                 \}}
\DoxyCodeLine{417             \}}
\DoxyCodeLine{418             \textcolor{comment}{// run with a probability}}
\DoxyCodeLine{419             \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_base\_of<dena::run\_with\_probability\_node, T\_n>::value)\{}
\DoxyCodeLine{420                 \textcolor{keywordtype}{float} sample = utils::random::uniform<float>(0.0, 1.0);}
\DoxyCodeLine{421                 \textcolor{keywordflow}{if}(sample < node.prob)\{}
\DoxyCodeLine{422                     (*traverse\_fn)(node.sub\_procedure.front(), problem, main\_storage);}
\DoxyCodeLine{423                 \}}
\DoxyCodeLine{424             \}}
\DoxyCodeLine{425             \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_base\_of<dena::run\_every\_n\_steps\_node, T\_n>::value)\{}
\DoxyCodeLine{426                 \textcolor{keywordtype}{int} p = main\_storage-\/>iter\_counter[node.tag];}
\DoxyCodeLine{427                 main\_storage-\/>iter\_counter[node.tag] = (p+1) \% node.period;}
\DoxyCodeLine{428                 \textcolor{keywordflow}{if}(p == 0)}
\DoxyCodeLine{429                     (*traverse\_fn)(node.sub\_procedure.front(), problem, main\_storage);}
\DoxyCodeLine{430             \}}
\DoxyCodeLine{431             \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_base\_of<dena::run\_until\_no\_improve\_node, T\_n>::value)\{}
\DoxyCodeLine{432                 \textcolor{keywordtype}{int} checks = 0;}
\DoxyCodeLine{433                 T\_e value = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(node.id)-\/>best\_min();}
\DoxyCodeLine{434                 \textcolor{keywordflow}{while}(checks < node.max\_check)\{}
\DoxyCodeLine{435                     T\_e last\_value = main\_storage-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage_a2df2092dc41d02bbc5fd7407cbc4a2d0}{container}}(node.id)-\/>best\_min();}
\DoxyCodeLine{436                     checks++;}
\DoxyCodeLine{437                     \textcolor{keywordflow}{if}(last\_value < value)}
\DoxyCodeLine{438                         checks = 0;}
\DoxyCodeLine{439                     value = last\_value;}
\DoxyCodeLine{440                     \textcolor{comment}{// run the sub-\/procedure}}
\DoxyCodeLine{441                     (*traverse\_fn)(node.sub\_procedure.front(), problem, main\_storage);}
\DoxyCodeLine{442                 \}}
\DoxyCodeLine{443                     }
\DoxyCodeLine{444             \}}
\DoxyCodeLine{445             \textcolor{keywordflow}{return};}
\DoxyCodeLine{446         \}}
\DoxyCodeLine{447         \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_base\_of<dena::bcd\_mask\_node, T\_n>::value)\{}
\DoxyCodeLine{448             \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr}(T\_block\_dim == T\_dim)}
\DoxyCodeLine{449                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{450             \textcolor{comment}{// synchronize best values for the current state over the cluster}}
\DoxyCodeLine{451             main\_storage-\/>update\_partial\_best();}
\DoxyCodeLine{452             main\_storage-\/>sync\_partial\_best();}
\DoxyCodeLine{453             spdlog::info(\textcolor{stringliteral}{"{}synchronizing BCD mask. best solution: \{\}"{}}, main\_storage-\/>partial\_best-\/>values[0]);}
\DoxyCodeLine{454             \textcolor{comment}{// generate a new mask}}
\DoxyCodeLine{455             main\_storage-\/>str\_storage[node.tag][0]-\/>apply();}
\DoxyCodeLine{456             \textcolor{comment}{// synchronize the generated mask}}
\DoxyCodeLine{457             main\_storage-\/>str\_storage[node.tag][1]-\/>apply();}
\DoxyCodeLine{458             \textcolor{comment}{// reset all solution containers}}
\DoxyCodeLine{459             main\_storage-\/>reset();}
\DoxyCodeLine{460             \textcolor{keywordflow}{return};}
\DoxyCodeLine{461         \}}
\DoxyCodeLine{462         \textcolor{keywordflow}{if} (main\_storage-\/>str\_storage.find(node.tag) != main\_storage-\/>str\_storage.end())\{}
\DoxyCodeLine{463             \textcolor{keywordflow}{for}(\textcolor{keyword}{auto}\& str: main\_storage-\/>str\_storage[node.tag])\{}
\DoxyCodeLine{464                 str-\/>apply();}
\DoxyCodeLine{465                 main\_storage-\/>update\_partial\_best();}
\DoxyCodeLine{466             \}}
\DoxyCodeLine{467         \}}
\DoxyCodeLine{468         }
\DoxyCodeLine{469        }
\DoxyCodeLine{470     \}}
\DoxyCodeLine{471 \};}
\DoxyCodeLine{472 }
\DoxyCodeLine{477 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T\_e, \textcolor{keywordtype}{int} T\_dim, \textcolor{keywordtype}{int} T\_block\_dim=T\_dim>}
\DoxyCodeLine{478 \textcolor{keyword}{class }\mbox{\hyperlink{classrocky_1_1zagros_1_1basic__runtime}{basic\_runtime}}\{}
\DoxyCodeLine{479 \textcolor{keyword}{public}:}
\DoxyCodeLine{480     \textcolor{comment}{// objective system}}
\DoxyCodeLine{481     \mbox{\hyperlink{classrocky_1_1zagros_1_1system}{system<T\_e>}}* problem;}
\DoxyCodeLine{482     std::unique\_ptr<blocked\_system<T\_e>> blocked\_problem;}
\DoxyCodeLine{483     \mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage}{runtime\_storage<T\_e, T\_dim, T\_block\_dim>}} storage;}
\DoxyCodeLine{484 }
\DoxyCodeLine{485     \textcolor{comment}{// check if the objective system is blocked }}
\DoxyCodeLine{486     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} blocked()\{}
\DoxyCodeLine{487         \textcolor{keywordflow}{return} T\_dim != T\_block\_dim;}
\DoxyCodeLine{488     \}}
\DoxyCodeLine{489     \textcolor{comment}{// get problem}}
\DoxyCodeLine{490     \mbox{\hyperlink{classrocky_1_1zagros_1_1system}{system<T\_e>}}* get\_problem()\{}
\DoxyCodeLine{491         \textcolor{keywordflow}{if}(blocked())}
\DoxyCodeLine{492             \textcolor{keywordflow}{return} blocked\_problem.get();}
\DoxyCodeLine{493         \textcolor{keywordflow}{else}}
\DoxyCodeLine{494             \textcolor{keywordflow}{return} problem;}
\DoxyCodeLine{495     \}}
\DoxyCodeLine{496     \mbox{\hyperlink{classrocky_1_1zagros_1_1basic__runtime}{basic\_runtime}}(\mbox{\hyperlink{classrocky_1_1zagros_1_1system}{system<T\_e>}}* problem)\{}
\DoxyCodeLine{497         this-\/>problem = problem;}
\DoxyCodeLine{498         storage.partial\_best = std::make\_unique<basic\_scontainer<T\_e, T\_block\_dim>>(1, 1);}
\DoxyCodeLine{499         storage.partial\_best-\/>allocate();}
\DoxyCodeLine{500         \textcolor{keywordflow}{if} (blocked())\{}
\DoxyCodeLine{501             storage.bcd\_mask.resize(T\_block\_dim);}
\DoxyCodeLine{502             std::iota(storage.bcd\_mask.begin(), storage.bcd\_mask.end(), 0);}
\DoxyCodeLine{503             this-\/>blocked\_problem = std::make\_unique<blocked\_system<T\_e>>(problem, T\_dim, T\_block\_dim, storage.bcd\_mask.data());}
\DoxyCodeLine{504             sync\_bcd\_mask<T\_e, T\_block\_dim> sync\_mask\_str(storage.bcd\_mask.data());}
\DoxyCodeLine{505             spdlog::info(\textcolor{stringliteral}{"{}broadcasting BCD mask..."{}});}
\DoxyCodeLine{506             sync\_mask\_str.apply();}
\DoxyCodeLine{507             \textcolor{comment}{// initialize and sync the bcd state}}
\DoxyCodeLine{508             storage.blocked\_state = std::make\_unique<basic\_scontainer<T\_e, T\_dim>>(1, 1);}
\DoxyCodeLine{509             storage.blocked\_state-\/>allocate();}
\DoxyCodeLine{510             \mbox{\hyperlink{classrocky_1_1zagros_1_1uniform__init__strategy}{uniform\_init\_strategy<T\_e, T\_dim>}} init\_bcd\_state(problem, storage.blocked\_state.get());}
\DoxyCodeLine{511             init\_bcd\_state.apply();}
\DoxyCodeLine{512             \textcolor{comment}{// briadcast the initialized solution}}
\DoxyCodeLine{513             spdlog::info(\textcolor{stringliteral}{"{}broadcasting initial BCD solution state..."{}});}
\DoxyCodeLine{514             sync\_broadcast\_best<T\_e, T\_dim> sync\_bcd\_state\_str(storage.blocked\_state.get());}
\DoxyCodeLine{515             sync\_bcd\_state\_str.apply();}
\DoxyCodeLine{516             storage.th\_blocked\_states = tbb::enumerable\_thread\_specific<std::vector<T\_e>>(storage.blocked\_state-\/>particles[0]);}
\DoxyCodeLine{517             this-\/>blocked\_problem-\/>set\_solution\_state(\&(storage.th\_blocked\_states));}
\DoxyCodeLine{518             }
\DoxyCodeLine{519         \} }
\DoxyCodeLine{520     \}}
\DoxyCodeLine{521     \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} \mbox{\hyperlink{classrocky_1_1zagros_1_1dena_1_1flow}{dena::flow}}\& fl)\{}
\DoxyCodeLine{522         \textcolor{comment}{// allocate memory for running the flow}}
\DoxyCodeLine{523         this-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1basic__runtime_afdfd7b7c217786a4f886f927872c02f8}{traverse\_allocate}}(fl);}
\DoxyCodeLine{524         spdlog::info(\textcolor{stringliteral}{"{}allocation finished"{}});}
\DoxyCodeLine{525         spdlog::info(\textcolor{stringliteral}{"{}total runtime storage : \{:.2f\} MB"{}}, this-\/>storage.container\_space()/(1024.0*1024.0));}
\DoxyCodeLine{526         \textcolor{comment}{// allocate and assign strategies}}
\DoxyCodeLine{527         this-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1basic__runtime_ad0c6b8b46f661c8453c19eb79c71cb15}{traverse\_assign}}(fl);}
\DoxyCodeLine{528         spdlog::info(\textcolor{stringliteral}{"{}assignment finished"{}});}
\DoxyCodeLine{529         \textcolor{comment}{// run the flow recursively}}
\DoxyCodeLine{530         this-\/>\mbox{\hyperlink{classrocky_1_1zagros_1_1basic__runtime_a89be3d7f767c5b91914506c7a23f3727}{traverse\_run}}(fl);}
\DoxyCodeLine{531     \}}
\DoxyCodeLine{538     \textcolor{keywordtype}{void} \mbox{\hyperlink{classrocky_1_1zagros_1_1basic__runtime_afdfd7b7c217786a4f886f927872c02f8}{traverse\_allocate}}(\textcolor{keyword}{const} \mbox{\hyperlink{classrocky_1_1zagros_1_1dena_1_1flow}{dena::flow}}\& fl)\{}
\DoxyCodeLine{539         \textcolor{keyword}{auto} it = fl.procedure.front();}
\DoxyCodeLine{540         \textcolor{comment}{// storage for the traversed path}}
\DoxyCodeLine{541         std::stack<int> path;}
\DoxyCodeLine{542         \textcolor{comment}{// visitor}}
\DoxyCodeLine{543         \mbox{\hyperlink{structrocky_1_1zagros_1_1allocation__visitor}{allocation\_visitor<T\_e, T\_dim, T\_block\_dim>}} alloc\_visitor \{get\_problem(), \&storage, \&path\}; }
\DoxyCodeLine{544         \textcolor{comment}{// initialize the path}}
\DoxyCodeLine{545         path.push(it);}
\DoxyCodeLine{546         \textcolor{comment}{// iterate until there is no node in the stack}}
\DoxyCodeLine{547         \textcolor{keywordflow}{while}(!path.empty())\{}
\DoxyCodeLine{548             it = path.top();}
\DoxyCodeLine{549             \textcolor{comment}{// remove the visited node}}
\DoxyCodeLine{550             path.pop();}
\DoxyCodeLine{551             \textcolor{keyword}{auto} current = dena::node::nodes[it];}
\DoxyCodeLine{552             \textcolor{comment}{// push the next node into the stack if it's not null}}
\DoxyCodeLine{553             it = dena::node::next(it);}
\DoxyCodeLine{554             \textcolor{keywordflow}{if}(it > -\/1)}
\DoxyCodeLine{555                 path.push(it);  }
\DoxyCodeLine{556             \textcolor{comment}{// visit the node}}
\DoxyCodeLine{557             std::visit(alloc\_visitor, current);      }
\DoxyCodeLine{558         \}  }
\DoxyCodeLine{559     \}}
\DoxyCodeLine{566     \textcolor{keywordtype}{void} \mbox{\hyperlink{classrocky_1_1zagros_1_1basic__runtime_ad0c6b8b46f661c8453c19eb79c71cb15}{traverse\_assign}}(\textcolor{keyword}{const} \mbox{\hyperlink{classrocky_1_1zagros_1_1dena_1_1flow}{dena::flow}}\& fl)\{}
\DoxyCodeLine{567         \textcolor{keyword}{auto} it = fl.procedure.front();}
\DoxyCodeLine{568         \textcolor{comment}{// storage for the traversed path}}
\DoxyCodeLine{569         std::stack<int> path;}
\DoxyCodeLine{570         \textcolor{comment}{// visitor}}
\DoxyCodeLine{571         \mbox{\hyperlink{structrocky_1_1zagros_1_1assigning__visitor}{assigning\_visitor<T\_e, T\_dim, T\_block\_dim>}} assign\_visitor \{get\_problem(), \&storage, \&path\}; }
\DoxyCodeLine{572         \textcolor{comment}{// initialize the path}}
\DoxyCodeLine{573         path.push(it);}
\DoxyCodeLine{574         \textcolor{comment}{// iterate until there is no node in the stack}}
\DoxyCodeLine{575         \textcolor{keywordflow}{while}(!path.empty())\{}
\DoxyCodeLine{576             it = path.top();}
\DoxyCodeLine{577             \textcolor{comment}{// remove the visited node}}
\DoxyCodeLine{578             path.pop();}
\DoxyCodeLine{579             \textcolor{keyword}{auto} current = dena::node::nodes[it];}
\DoxyCodeLine{580             \textcolor{comment}{// push the next node into the stack if it's not null}}
\DoxyCodeLine{581             it = dena::node::next(it);}
\DoxyCodeLine{582             \textcolor{keywordflow}{if}(it > -\/1)}
\DoxyCodeLine{583                 path.push(it);  }
\DoxyCodeLine{584             \textcolor{comment}{// visit the node}}
\DoxyCodeLine{585             std::visit(assign\_visitor, current);      }
\DoxyCodeLine{586         \}  }
\DoxyCodeLine{587     \}}
\DoxyCodeLine{588     \textcolor{keyword}{static} \textcolor{keywordtype}{void} traverse\_run\_rec(\textcolor{keywordtype}{int} root, \mbox{\hyperlink{classrocky_1_1zagros_1_1system}{system<T\_e>}}* problem, \mbox{\hyperlink{classrocky_1_1zagros_1_1runtime__storage}{runtime\_storage<T\_e, T\_dim, T\_block\_dim>}}* storage)\{}
\DoxyCodeLine{589         \textcolor{keywordflow}{if}(root == -\/1)}
\DoxyCodeLine{590             \textcolor{keywordflow}{return};}
\DoxyCodeLine{591         \textcolor{comment}{// visitor}}
\DoxyCodeLine{592         \mbox{\hyperlink{structrocky_1_1zagros_1_1running__visitor}{running\_visitor}}<T\_e, T\_dim, T\_block\_dim, \textcolor{keyword}{decltype}(traverse\_run\_rec)> run\_visitor \{problem, storage, \&traverse\_run\_rec\}; }
\DoxyCodeLine{593         \textcolor{comment}{// iterate until there is no node left in the stack}}
\DoxyCodeLine{594         \textcolor{keyword}{auto} node = dena::node::nodes[root];}
\DoxyCodeLine{595         std::visit(run\_visitor, node);}
\DoxyCodeLine{596         traverse\_run\_rec(dena::node::next(root), problem, storage);}
\DoxyCodeLine{597     \}}
\DoxyCodeLine{604     \textcolor{keywordtype}{void} \mbox{\hyperlink{classrocky_1_1zagros_1_1basic__runtime_a89be3d7f767c5b91914506c7a23f3727}{traverse\_run}}(\textcolor{keyword}{const} \mbox{\hyperlink{classrocky_1_1zagros_1_1dena_1_1flow}{dena::flow}}\& fl)\{}
\DoxyCodeLine{605         \textcolor{comment}{// running the flow and sub-\/flows recursively}}
\DoxyCodeLine{606         this-\/>traverse\_run\_rec(fl.procedure.front(), get\_problem(), \&storage);}
\DoxyCodeLine{607     \}}
\DoxyCodeLine{608 \};}
\DoxyCodeLine{609 }
\DoxyCodeLine{610 }
\DoxyCodeLine{611 \}; \textcolor{comment}{// end of zagros}}
\DoxyCodeLine{612 \}; \textcolor{comment}{// end of rocky}}
\DoxyCodeLine{613 \textcolor{preprocessor}{\#endif}}

\end{DoxyCode}
