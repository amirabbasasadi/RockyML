<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RockyML: Distributed optimization, Basic example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rockyml-docs-200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RockyML
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">A High-Performance Scientific Computing Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('zagros_distributed.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Distributed optimization, Basic example </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><center></center><center><img src="distributed.png" alt="" class="inline"/></center><center></center><p>This is a basic example of using Zagros and Dena for distributed optimization. Currently Zagros uses MPI as the backend for communication so MPI should be properly initialized in your code:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;mpi.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;rocky/zagros/benchmark.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;rocky/zagros/flow.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>rocky::zagros;</div>
<div class="line"><span class="keyword">using namespace </span>rocky::zagros::dena;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]){</div>
<div class="line">    MPI_Init(&amp;argc, &amp;argv);</div>
<div class="line">    </div>
<div class="line"> </div>
<div class="line">    MPI_Finalize();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now suppose we have the following optimizer in Dena: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> optimizer = container::create(<span class="stringliteral">&quot;A&quot;</span>, 1000)</div>
<div class="line">                &gt;&gt; init::uniform(<span class="stringliteral">&quot;A&quot;</span>) </div>
<div class="line">                &gt;&gt; run::n_times(500,</div>
<div class="line">                    eda::mvn::full_cov(<span class="stringliteral">&quot;A&quot;</span>)</div>
<div class="line">                    &gt;&gt; crossover::segment(<span class="stringliteral">&quot;A&quot;</span>, 4)</div>
<div class="line">                );</div>
</div><!-- fragment --><p>This optimizer is a simple mixture of EDA and Genetic crossovers. After defining the problem and runtime you can simply execute it using MPI: </p><div class="fragment"><div class="line"><span class="comment">// define the optimization problem</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> dim = 100;</div>
<div class="line">benchmark::rastrigin&lt;float&gt; problem(dim);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create a runtime for executing the optimizer </span></div>
<div class="line">basic_runtime&lt;float, dim&gt; runtime(&amp;problem);</div>
<div class="line">runtime.run(optimizer);</div>
</div><!-- fragment --><p>And the execution: </p><div class="fragment"><div class="line">mpirun -np 1 ./app</div>
</div><!-- fragment --><p>The above command will execute the optimizer with a single process. for execution with 2 processes we can just change the <code>-np</code> parameter: </p><div class="fragment"><div class="line">mpirun -np 2 ./app</div>
</div><!-- fragment --><p>Also don't forget to assign the proper resources to your processes. for example maybe you like to assign 2 CPU threads to each process: </p><div class="fragment"><div class="line">mpirun --use-hwthread-cpus -np 2 --map-by socket:PE=2 ./app</div>
</div><!-- fragment --><p>Read more about <a href="https://www.ibm.com/docs/en/smpi/10.2?topic=administering-managing-process-placement-affinity">process affinity</a> in the documentation of your MPI implementation. </p>
<h1><a class="anchor" id="autotoc_md24"></a>
Solution propagation</h1>
<p>So far if we execute the app, two processes will run simultaniously, however they are independent and don't exchange any information. Dena provides utilities for sharing the information among optimizers so all of them can use the best solution in cluster. Let's create another solution container called <code>best</code> for holding the best solution in a node: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> optimizer = container::create(<span class="stringliteral">&quot;A&quot;</span>, 1000)</div>
<div class="line">                    &gt;&gt; container::create(<span class="stringliteral">&quot;best&quot;</span>)</div>
<div class="line">                    &gt;&gt; init::uniform(<span class="stringliteral">&quot;A&quot;</span>) </div>
<div class="line">                    &gt;&gt; run::n_times(500,</div>
<div class="line">                        eda::mvn::full_cov(<span class="stringliteral">&quot;A&quot;</span>)</div>
<div class="line">                        &gt;&gt; crossover::segment(<span class="stringliteral">&quot;A&quot;</span>, 4)</div>
<div class="line">                    );</div>
</div><!-- fragment --><p>To update the <code>best</code> we can use <code>container::take_best(dest, src)</code> syntax. This command takes the name of two containers as input namely a "destination" container and a "source". if the best solution in the source is better than the worst solution in the destination, the solution in the source will be replaced. To ensure it contains the best solution we can update it at each step: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> optimizer = container::create(<span class="stringliteral">&quot;A&quot;</span>, 1000)</div>
<div class="line">                    &gt;&gt; container::create(<span class="stringliteral">&quot;best&quot;</span>)</div>
<div class="line">                    &gt;&gt; init::uniform(<span class="stringliteral">&quot;A&quot;</span>) </div>
<div class="line">                    &gt;&gt; run::n_times(500,</div>
<div class="line">                        eda::mvn::full_cov(<span class="stringliteral">&quot;A&quot;</span>)</div>
<div class="line">                        &gt;&gt; crossover::segment(<span class="stringliteral">&quot;A&quot;</span>, 4)</div>
<div class="line">                        &gt;&gt; container::take_best(<span class="stringliteral">&quot;best&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>)</div>
<div class="line">                    );</div>
</div><!-- fragment --><p>Now we are sure that <code>best</code> holds the best solution in this process. Next we are going to ask all processes in the cluster, who has the best value for this container? whoever is it, should broadcast it for everyone else. To do so we can simply use <code>propagate::cluster::best()</code> like this: </p><div class="fragment"><div class="line">propagate::cluster::best(<span class="stringliteral">&quot;best&quot;</span>)</div>
</div><!-- fragment --><p>However note this is a collective call performing a synchronization for all processes, so it's better not to call it frequently: </p><div class="fragment"><div class="line">run::ever_n_steps(100,</div>
<div class="line">    propagate::cluster::best(<span class="stringliteral">&quot;best&quot;</span>)</div>
<div class="line">)</div>
</div><!-- fragment --><p>Now we need to make sure the retreived solution will be available in <code>A</code> so the mutation and EDA algorithms can use it. </p><div class="fragment"><div class="line">run::ever_n_steps(100,</div>
<div class="line">    propagate::cluster::best(<span class="stringliteral">&quot;best&quot;</span>)</div>
<div class="line">    &gt;&gt; container::take_best(<span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;best&quot;</span>)</div>
<div class="line">)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md25"></a>
Tracking the result using Comet</h1>
<p>Suppose you have many nodes and you want to track the best found solution in all of them. In addition to local logging, Dena supports logging the result on <a href="https://comet.ml/">Comet</a>. First you need to create a <code>comet_log_handler</code> object: </p><div class="fragment"><div class="line">comet_log_handler log_handler(<span class="stringliteral">&quot;YOUR_COMET_API_KEY&quot;</span>, <span class="stringliteral">&quot;workspace&quot;</span>, <span class="stringliteral">&quot;project&quot;</span>, <span class="stringliteral">&quot;best_solution&quot;</span>);</div>
</div><!-- fragment --><p>Now using <code>log::comet::best(cnt, log_handler)</code>, we can log the best solution in container <code>cnt</code> at each step. Do the possible latency for sending the result to Comet server, we can perform this operation with a certain probability: </p><div class="fragment"><div class="line">run::with_probability(0.1,</div>
<div class="line">    log::comet::best(<span class="stringliteral">&quot;best&quot;</span>, log_handler)</div>
<div class="line">)</div>
</div><!-- fragment --><p>Now the result are available in your Comet dashbord. </p>
<h1><a class="anchor" id="autotoc_md26"></a>
Conclusion</h1>
<p>In this tutorial we saw a basic example of designing a distributed optimizer, basic syntax for solution propagation, and tracking the experiment using Comet. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> optimizer = container::create(<span class="stringliteral">&quot;A&quot;</span>, 1000)</div>
<div class="line">                    &gt;&gt; container::create(<span class="stringliteral">&quot;best&quot;</span>)</div>
<div class="line">                    &gt;&gt; init::uniform(<span class="stringliteral">&quot;A&quot;</span>) </div>
<div class="line">                    &gt;&gt; run::n_times(500,</div>
<div class="line">                        eda::mvn::full_cov(<span class="stringliteral">&quot;A&quot;</span>)</div>
<div class="line">                        &gt;&gt; crossover::segment(<span class="stringliteral">&quot;A&quot;</span>, 4)</div>
<div class="line">                        &gt;&gt; container::take_best(<span class="stringliteral">&quot;best&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>)</div>
<div class="line">                        &gt;&gt; run::every_n_steps(200,</div>
<div class="line">                            propagate::cluster::best(<span class="stringliteral">&quot;best&quot;</span>)</div>
<div class="line">                            &gt;&gt; container::take_best(<span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;best&quot;</span>)</div>
<div class="line">                        )</div>
<div class="line">                        &gt;&gt; run::with_probability(0.1,</div>
<div class="line">                            log::comet::best(<span class="stringliteral">&quot;best&quot;</span>, log_handler)</div>
<div class="line">                        )</div>
<div class="line">                    );</div>
</div><!-- fragment --><p>The complete source code for this example is available <a href="https://github.com/amirabbasasadi/RockyML/tree/main/examples/zagros_distributed">here</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="guide.html">Guide</a></li><li class="navelem"><a class="el" href="zagros.html">Zagros | An Optimization Framework for HPC Clusters</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
