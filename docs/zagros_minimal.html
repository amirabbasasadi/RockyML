<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RockyML: Create your first optimizer with Dena and Zagros</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rockyml-docs-200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RockyML
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">A High-Performance Scientific Computing Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('zagros_minimal.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Create your first optimizer with Dena and Zagros </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this example we design an optimizer in Dena step by step and then we will see how to execute it using Zagros runtime. But first, make sure you have read <a class="el" href="build.html">Using RockyML with CMake</a>. Here is a blank template for beginning: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;mpi.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;rocky/zagros/benchmark.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;rocky/zagros/flow.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>rocky::zagros;</div>
<div class="line"><span class="keyword">using namespace </span>rocky::zagros::dena;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]){</div>
<div class="line">    MPI_Init(&amp;argc, &amp;argv);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// our code</span></div>
<div class="line"> </div>
<div class="line">    MPI_Finalize();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md10"></a>
Problem Definition</h1>
<p>We are going to minimize the Rastrigin function defined as: <br  />
 </p><p class="formulaDsp">
\[ f(\mathbf{x})=10n+\sum _{i=1}^{n}\left[x_{i}^{2}-10\cos(2\pi x_{i})\right] \]
</p>
<p> <br  />
 On the domain \( \mathbf{x} \in \left[ -5.12,5.12 \right]^{n} \) where \( n=100 \). Before everything, let's know our objective function better. Rastrigin is a famous function in optimization literature. If we plot it for \( n=2 \) we have: </p><center> <table class="doxtable">
<tr>
<th>Heat Map </th><th>Surface  </th></tr>
<tr>
<td><img src="zagros_rastrigin_0_heatmap.png" alt="" width="300px" class="inline"/> </td><td><img src="zagros_rastrigin_0_surface.png" alt="" width="300px" class="inline"/>  </td></tr>
</table>
</center><p> As you can see it has so many local minimums. In fact, as the dimension increases, the number of local minimums increases exponentially! On the domain of \( \left[ -5.12,5.12 \right]^{100} \) it has \( 11^{100} \) local minimums ðŸ˜±. The global minimum is located at \( \mathbf{x} = 0 \). Since Rastrigin is a famous function, it's available in the set of test functions in Zagros</p>
<div class="fragment"><div class="line"><span class="comment">// objective dimension</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> n = 100;</div>
<div class="line"><span class="comment">// define rastrigin function</span></div>
<div class="line">benchmark::rastrigin&lt;float&gt; objective(n);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md11"></a>
A simple optimizer</h1>
<p>Next we need to describe our optimizer. Dena is a language for specifying optimization algorithms. Using Dena, you can focus on the optimization procedure and leave the execution to Zagros runtime. There are many search methods for black-box optimization, you can freely combine them in various ways. To illustrate how this works, we begin with a very simple optimizer then slightly evolve it to a complex algorithm for optimization.</p>
<p>In Zagros, a <em>solution container</em> holds a set of potential solutions to an optimization problem. An optimizer essentially acts on the containers to improve their solutions gradually. Thus the first step is to create a solution container: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> optimizer = container::create(<span class="stringliteral">&quot;A&quot;</span>);</div>
</div><!-- fragment --><p>The above code, simply create a container <code>A</code> containing a solution. So far we have only a single solution. We can initialize it now: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> optimizer = container::create(<span class="stringliteral">&quot;A&quot;</span>) &gt;&gt; init::uniform(<span class="stringliteral">&quot;A&quot;</span>);</div>
</div><!-- fragment --><p>This will initialize the solution using a uniform distribution. <code>container::create</code> and <code>init::uniform</code> are called <em>optimization flow</em>. A flow is a sequence of operations in Zagros optimizers. you can combine flows using operator <code>&gt;&gt;</code> to create more complex flows. Dena supports various flows each one for a different purpose. After initializing we can use search strategies to improve the solution. A simple strategy might be adding a gaussian noise to the solution and keep the changes if it causes any improvement: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> optimizer = container::create(<span class="stringliteral">&quot;A&quot;</span>) </div>
<div class="line">                &gt;&gt; init::uniform(<span class="stringliteral">&quot;A&quot;</span>)</div>
<div class="line">                &gt;&gt; mutate::gaussian(<span class="stringliteral">&quot;A&quot;</span>);</div>
</div><!-- fragment --><p><code>mutate::gaussian</code> adds a gaussian noise to the solutions and update them if the noise improves them. Of course we can control the number of affected dimensions and parameters of the noise if we like. By repeating this procedure we obtain a simple hill climbing. To repeat a flow you can use <code>run::n_times</code>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> optimizer = container::create(<span class="stringliteral">&quot;A&quot;</span>)</div>
<div class="line">                &gt;&gt; init::uniform(<span class="stringliteral">&quot;A&quot;</span>) </div>
<div class="line">                &gt;&gt; run::n_times(500,</div>
<div class="line">                      mutate::gaussian(<span class="stringliteral">&quot;A&quot;</span>)</div>
<div class="line">                );</div>
</div><!-- fragment --><p><code>run::n_times(100, f)</code> will run a flow <code>f</code> for <code>100</code> times. let's see the performance of our simple optimizer. <code>log::local::best</code> is a utility for recording best solution in a container. Using <code>log::local::best</code> we can store the best found solution in each time step in a local file. Dena also provides utilities for logging on a remote tracker like <a href="https://www.comet.ml/">Comet</a>. To specify the output of logging we should create a <code>local_log_handler</code> object: </p><div class="fragment"><div class="line">local_log_handler log_handler(<span class="stringliteral">&quot;result.csv&quot;</span>);</div>
</div><!-- fragment --><p>The result will be stored in a file called <code>result.csv</code>. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> optimizer = container::create(<span class="stringliteral">&quot;A&quot;</span>)</div>
<div class="line">                &gt;&gt; init::uniform(<span class="stringliteral">&quot;A&quot;</span>) </div>
<div class="line">                &gt;&gt; run::n_times(500,</div>
<div class="line">                      mutate::gaussian(<span class="stringliteral">&quot;A&quot;</span>)</div>
<div class="line">                      &gt;&gt; log::local::best(<span class="stringliteral">&quot;A&quot;</span>, log_handler)</div>
<div class="line">                );</div>
</div><!-- fragment --><p>After designing the optimizer we should execute it using Zagros runtime: </p><div class="fragment"><div class="line"><span class="comment">// create a runtime for executing the optimizer </span></div>
<div class="line">zagros::basic_runtime&lt;float, dim&gt; runtime(&amp;problem);</div>
<div class="line">runtime.run(optimizer);</div>
</div><!-- fragment --><p>So the full example would be: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;mpi.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;rocky/zagros/benchmark.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;rocky/zagros/flow.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>rocky::zagros;</div>
<div class="line"><span class="keyword">using namespace </span>rocky::zagros::dena;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]){</div>
<div class="line">    MPI_Init(&amp;argc, &amp;argv);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// define the optimization problem</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> dim = 100;</div>
<div class="line">    <a class="code" href="classrocky_1_1zagros_1_1benchmark_1_1rastrigin.html">benchmark::rastrigin&lt;float&gt;</a> problem(dim);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// recording the result of optimization</span></div>
<div class="line">    <a class="code" href="structrocky_1_1zagros_1_1local__log__handler.html">local_log_handler</a> log_handler(<span class="stringliteral">&quot;result.csv&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// define the optimizer</span></div>
<div class="line">    <span class="keyword">auto</span> optimizer = <a class="code" href="classrocky_1_1zagros_1_1dena_1_1container.html#a4e35d0e45a4074d6db51ef53501dc19b">container::create</a>(<span class="stringliteral">&quot;A&quot;</span>, 300)</div>
<div class="line">                    &gt;&gt; <a class="code" href="classrocky_1_1zagros_1_1dena_1_1init.html#a5ba672657504454a994586320fb3d789">init::uniform</a>(<span class="stringliteral">&quot;A&quot;</span>) </div>
<div class="line">                    &gt;&gt; <a class="code" href="classrocky_1_1zagros_1_1dena_1_1run.html#a7b5c3755a7a924c668f970e0ff3dbe03">run::n_times</a>(500,</div>
<div class="line">                            <a class="code" href="classrocky_1_1zagros_1_1dena_1_1mutate.html#a40e1487a23fd5b8266e63449943be48a">mutate::gaussian</a>(<span class="stringliteral">&quot;A&quot;</span>)</div>
<div class="line">                            &gt;&gt; <a class="code" href="classrocky_1_1zagros_1_1dena_1_1log_1_1local.html#ade91fdad98fb0a863325b7edfff7b115">log::local::best</a>(<span class="stringliteral">&quot;A&quot;</span>, log_handler)</div>
<div class="line">                        );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// create a runtime for executing the optimizer </span></div>
<div class="line">    <a class="code" href="classrocky_1_1zagros_1_1basic__runtime.html">basic_runtime&lt;float, dim&gt;</a> runtime(&amp;problem);</div>
<div class="line">    runtime.run(optimizer);</div>
<div class="line"> </div>
<div class="line">    MPI_Finalize();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>After compiling the program, we should run it using MPI: </p><div class="fragment"><div class="line">mpirun -np 1 ./app</div>
</div><!-- fragment --><p>And if we plot the results stored in this file, we have: <br  />
 </p><div class="image">
<img src="tutorials_SHC.png" alt=""/>
</div>
<p> Hmmm, not so bad. It seems we trapped in one of those local minimums. Perhaps we should run this algorithms multiple times. So why not run them in parallel?</p>
<h1><a class="anchor" id="autotoc_md12"></a>
A parallel optimizer</h1>
<p>In the previous example <code>container::create("A")</code> created a single solution (particle) for us. To construct a parallel variant of stochastic hill climbing we can simply create a container with more solutions. </p><div class="fragment"><div class="line">container::create(<span class="stringliteral">&quot;A&quot;</span>, 300)</div>
</div><!-- fragment --><p>So now we have: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> optimizer = container::create(<span class="stringliteral">&quot;A&quot;</span>, 300)</div>
<div class="line">                &gt;&gt; init::uniform(<span class="stringliteral">&quot;A&quot;</span>) </div>
<div class="line">                &gt;&gt; run::n_times(500,</div>
<div class="line">                      mutate::gaussian(<span class="stringliteral">&quot;A&quot;</span>)</div>
<div class="line">                      &gt;&gt; log::local::best(<span class="stringliteral">&quot;A&quot;</span>, log_handler)</div>
<div class="line">                );</div>
</div><!-- fragment --><p>Note if your CPU supports multi-threading, Zagros will exectue the optimization in parallel. But make sure you assign enough processing elements to the process when using <code>mpirun</code>. If we plot the result of this version: </p><div class="image">
<img src="tutorials_SHC_300.png" alt=""/>
</div>
<p> Some of population-based optimiztion algorithms are also available in Dena that can be applied on a solution container. For example you can use Differential Evolution with <code>crossover::differential_evolution</code>. But suppose instead of running it every time, we want to execute with a certain probability. To do so we can simply use <code>run::with_probability</code>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> optimizer = container::create(<span class="stringliteral">&quot;A&quot;</span>, 300)</div>
<div class="line">                &gt;&gt; init::uniform(<span class="stringliteral">&quot;A&quot;</span>) </div>
<div class="line">                &gt;&gt; run::n_times(500,</div>
<div class="line">                      mutate::gaussian(<span class="stringliteral">&quot;A&quot;</span>)</div>
<div class="line">                      &gt;&gt; run::with_probability(0.2,</div>
<div class="line">                          crossover::differential_evolution(<span class="stringliteral">&quot;A&quot;</span>)</div>
<div class="line">                      )</div>
<div class="line">                      &gt;&gt; log::local::best(<span class="stringliteral">&quot;A&quot;</span>, log_handler)</div>
<div class="line">                );</div>
</div><!-- fragment --><p>And not surprisingly a little more improvement: </p><div class="image">
<img src="tutorials_SHC_300_DE.png" alt=""/>
</div>
<p> Why not make it even more complicated ðŸ¤¡ ? </p><div class="fragment"><div class="line"><span class="keyword">auto</span> optimizer = container::create(<span class="stringliteral">&quot;A&quot;</span>, 300)</div>
<div class="line">                &gt;&gt; init::uniform(<span class="stringliteral">&quot;A&quot;</span>) </div>
<div class="line">                &gt;&gt; run::n_times(500,</div>
<div class="line">                      mutate::gaussian(<span class="stringliteral">&quot;A&quot;</span>)</div>
<div class="line">                      &gt;&gt; run::with_probability(0.2,</div>
<div class="line">                          crossover::differential_evolution(<span class="stringliteral">&quot;A&quot;</span>)</div>
<div class="line">                      )</div>
<div class="line">                      &gt;&gt; run::every_n_steps(4, </div>
<div class="line">                          eda::mvn::full_cov(<span class="stringliteral">&quot;A&quot;</span>)</div>
<div class="line">                      )</div>
<div class="line">                      &gt;&gt; log::local::best(<span class="stringliteral">&quot;A&quot;</span>, log_handler)</div>
<div class="line">                );</div>
</div><!-- fragment --><p><code>run::every_n_steps</code> as its name suggests, runs a flow every n steps. <code>eda::mvn::full_cov</code> is a variant of an evolution strategies called EDA (Estimation of Distribution Algorithm). And again ðŸ™„ if we plot the result: </p><div class="image">
<img src="tutorials_SHC_300_DE_EDA.png" alt=""/>
</div>
<p> We should stop since there is no honor in just stacking a few search algorithm on top of each other. But the point is, using Dena we can freely combine various algorithms in a unified way. The search strategies in Dena have parallel implementation so we should expect a speedup on CPUs with multiple cores: </p><div class="image">
<img src="performance.png" alt=""/>
</div>
 <h1><a class="anchor" id="autotoc_md13"></a>
Conclusion</h1>
<p>So far we have designed a single node optimizer. Zagros also provides facilities for distributed optimization like solution propagation in addition to other utilities for using optimizers on large-scale problems which will be covered in another tutorial. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="aclassrocky_1_1zagros_1_1dena_1_1container_html_a4e35d0e45a4074d6db51ef53501dc19b"><div class="ttname"><a href="classrocky_1_1zagros_1_1dena_1_1container.html#a4e35d0e45a4074d6db51ef53501dc19b">rocky::zagros::dena::container::create</a></div><div class="ttdeci">static flow create(std::string id, int n_particles, int group_size)</div><div class="ttdoc">create a solution</div><div class="ttdef"><b>Definition:</b> dena.h:221</div></div>
<div class="ttc" id="aclassrocky_1_1zagros_1_1benchmark_1_1rastrigin_html"><div class="ttname"><a href="classrocky_1_1zagros_1_1benchmark_1_1rastrigin.html">rocky::zagros::benchmark::rastrigin</a></div><div class="ttdef"><b>Definition:</b> benchmark.h:86</div></div>
<div class="ttc" id="aclassrocky_1_1zagros_1_1dena_1_1log_1_1local_html_ade91fdad98fb0a863325b7edfff7b115"><div class="ttname"><a href="classrocky_1_1zagros_1_1dena_1_1log_1_1local.html#ade91fdad98fb0a863325b7edfff7b115">rocky::zagros::dena::log::local::best</a></div><div class="ttdeci">static flow best(std::string id, local_log_handler &amp;handler)</div><div class="ttdoc">local logging strategies</div><div class="ttdef"><b>Definition:</b> dena.h:321</div></div>
<div class="ttc" id="aclassrocky_1_1zagros_1_1dena_1_1run_html_a7b5c3755a7a924c668f970e0ff3dbe03"><div class="ttname"><a href="classrocky_1_1zagros_1_1dena_1_1run.html#a7b5c3755a7a924c668f970e0ff3dbe03">rocky::zagros::dena::run::n_times</a></div><div class="ttdeci">static flow n_times(int iters, const flow &amp;wrapped_flow)</div><div class="ttdoc">run the wrapped flow n times [todo] there is a problem with the last node</div><div class="ttdef"><b>Definition:</b> dena.h:411</div></div>
<div class="ttc" id="astructrocky_1_1zagros_1_1local__log__handler_html"><div class="ttname"><a href="structrocky_1_1zagros_1_1local__log__handler.html">rocky::zagros::local_log_handler</a></div><div class="ttdef"><b>Definition:</b> log.h:27</div></div>
<div class="ttc" id="aclassrocky_1_1zagros_1_1dena_1_1init_html_a5ba672657504454a994586320fb3d789"><div class="ttname"><a href="classrocky_1_1zagros_1_1dena_1_1init.html#a5ba672657504454a994586320fb3d789">rocky::zagros::dena::init::uniform</a></div><div class="ttdeci">static flow uniform(std::string id)</div><div class="ttdoc">initialize particles uniformly</div><div class="ttdef"><b>Definition:</b> dena.h:303</div></div>
<div class="ttc" id="aclassrocky_1_1zagros_1_1basic__runtime_html"><div class="ttname"><a href="classrocky_1_1zagros_1_1basic__runtime.html">rocky::zagros::basic_runtime</a></div><div class="ttdoc">base class for all runtimes</div><div class="ttdef"><b>Definition:</b> flow.h:490</div></div>
<div class="ttc" id="aclassrocky_1_1zagros_1_1dena_1_1mutate_html_a40e1487a23fd5b8266e63449943be48a"><div class="ttname"><a href="classrocky_1_1zagros_1_1dena_1_1mutate.html#a40e1487a23fd5b8266e63449943be48a">rocky::zagros::dena::mutate::gaussian</a></div><div class="ttdeci">static flow gaussian(std::string id, int dims=1, float mu=0.0, float sigma=1.0)</div><div class="ttdoc">Gaussian mutation.</div><div class="ttdef"><b>Definition:</b> dena.h:624</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="guide.html">Guide</a></li><li class="navelem"><a class="el" href="zagros.html">Zagros | An Optimization Framework for HPC Clusters</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
